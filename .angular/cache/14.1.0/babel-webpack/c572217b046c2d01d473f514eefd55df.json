{"ast":null,"code":"import _createClass from \"/home/bja/projects/kaffeesatz-donation-website/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/home/bja/projects/kaffeesatz-donation-website/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"/home/bja/projects/kaffeesatz-donation-website/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/bja/projects/kaffeesatz-donation-website/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"/home/bja/projects/kaffeesatz-donation-website/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _slicedToArray from \"/home/bja/projects/kaffeesatz-donation-website/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toArray from \"/home/bja/projects/kaffeesatz-donation-website/node_modules/@babel/runtime/helpers/esm/toArray.js\";\n\n/**\n * @license Angular v14.1.0\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\nimport { computeMsgId } from '@angular/compiler';\nexport { computeMsgId as ɵcomputeMsgId } from '@angular/compiler';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * The character used to mark the start and end of a \"block\" in a `$localize` tagged string.\n * A block can indicate metadata about the message or specify a name of a placeholder for a\n * substitution expressions.\n *\n * For example:\n *\n * ```ts\n * $localize`Hello, ${title}:title:!`;\n * $localize`:meaning|description@@id:source message text`;\n * ```\n */\n\nvar BLOCK_MARKER$1 = ':';\n/**\n * The marker used to separate a message's \"meaning\" from its \"description\" in a metadata block.\n *\n * For example:\n *\n * ```ts\n * $localize `:correct|Indicates that the user got the answer correct: Right!`;\n * $localize `:movement|Button label for moving to the right: Right!`;\n * ```\n */\n\nvar MEANING_SEPARATOR = '|';\n/**\n * The marker used to separate a message's custom \"id\" from its \"description\" in a metadata block.\n *\n * For example:\n *\n * ```ts\n * $localize `:A welcome message on the home page@@myApp-homepage-welcome: Welcome!`;\n * ```\n */\n\nvar ID_SEPARATOR = '@@';\n/**\n * The marker used to separate legacy message ids from the rest of a metadata block.\n *\n * For example:\n *\n * ```ts\n * $localize `:@@custom-id␟2df64767cd895a8fabe3e18b94b5b6b6f9e2e3f0: Welcome!`;\n * ```\n *\n * Note that this character is the \"symbol for the unit separator\" (␟) not the \"unit separator\n * character\" itself, since that has no visual representation. See https://graphemica.com/%E2%90%9F.\n *\n * Here is some background for the original \"unit separator character\":\n * https://stackoverflow.com/questions/8695118/whats-the-file-group-record-unit-separator-control-characters-and-its-usage\n */\n\nvar LEGACY_ID_INDICATOR = \"\\u241F\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Parse a `$localize` tagged string into a structure that can be used for translation or\n * extraction.\n *\n * See `ParsedMessage` for an example.\n */\n\nfunction parseMessage(messageParts, expressions, location, messagePartLocations) {\n  var expressionLocations = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var substitutions = {};\n  var substitutionLocations = {};\n  var associatedMessageIds = {};\n  var metadata = parseMetadata(messageParts[0], messageParts.raw[0]);\n  var cleanedMessageParts = [metadata.text];\n  var placeholderNames = [];\n  var messageString = metadata.text;\n\n  for (var i = 1; i < messageParts.length; i++) {\n    var _parsePlaceholder = parsePlaceholder(messageParts[i], messageParts.raw[i]),\n        messagePart = _parsePlaceholder.messagePart,\n        _parsePlaceholder$pla = _parsePlaceholder.placeholderName,\n        placeholderName = _parsePlaceholder$pla === void 0 ? computePlaceholderName(i) : _parsePlaceholder$pla,\n        associatedMessageId = _parsePlaceholder.associatedMessageId;\n\n    messageString += \"{$\".concat(placeholderName, \"}\").concat(messagePart);\n\n    if (expressions !== undefined) {\n      substitutions[placeholderName] = expressions[i - 1];\n      substitutionLocations[placeholderName] = expressionLocations[i - 1];\n    }\n\n    placeholderNames.push(placeholderName);\n\n    if (associatedMessageId !== undefined) {\n      associatedMessageIds[placeholderName] = associatedMessageId;\n    }\n\n    cleanedMessageParts.push(messagePart);\n  }\n\n  var messageId = metadata.customId || computeMsgId(messageString, metadata.meaning || '');\n  var legacyIds = metadata.legacyIds ? metadata.legacyIds.filter(function (id) {\n    return id !== messageId;\n  }) : [];\n  return {\n    id: messageId,\n    legacyIds: legacyIds,\n    substitutions: substitutions,\n    substitutionLocations: substitutionLocations,\n    text: messageString,\n    customId: metadata.customId,\n    meaning: metadata.meaning || '',\n    description: metadata.description || '',\n    messageParts: cleanedMessageParts,\n    messagePartLocations: messagePartLocations,\n    placeholderNames: placeholderNames,\n    associatedMessageIds: associatedMessageIds,\n    location: location\n  };\n}\n/**\n * Parse the given message part (`cooked` + `raw`) to extract the message metadata from the text.\n *\n * If the message part has a metadata block this function will extract the `meaning`,\n * `description`, `customId` and `legacyId` (if provided) from the block. These metadata properties\n * are serialized in the string delimited by `|`, `@@` and `␟` respectively.\n *\n * (Note that `␟` is the `LEGACY_ID_INDICATOR` - see `constants.ts`.)\n *\n * For example:\n *\n * ```ts\n * `:meaning|description@@custom-id:`\n * `:meaning|@@custom-id:`\n * `:meaning|description:`\n * `:description@@custom-id:`\n * `:meaning|:`\n * `:description:`\n * `:@@custom-id:`\n * `:meaning|description@@custom-id␟legacy-id-1␟legacy-id-2:`\n * ```\n *\n * @param cooked The cooked version of the message part to parse.\n * @param raw The raw version of the message part to parse.\n * @returns A object containing any metadata that was parsed from the message part.\n */\n\n\nfunction parseMetadata(cooked, raw) {\n  var _splitBlock = splitBlock(cooked, raw),\n      messageString = _splitBlock.text,\n      block = _splitBlock.block;\n\n  if (block === undefined) {\n    return {\n      text: messageString\n    };\n  } else {\n    var _block$split = block.split(LEGACY_ID_INDICATOR),\n        _block$split2 = _toArray(_block$split),\n        meaningDescAndId = _block$split2[0],\n        legacyIds = _block$split2.slice(1);\n\n    var _meaningDescAndId$spl = meaningDescAndId.split(ID_SEPARATOR, 2),\n        _meaningDescAndId$spl2 = _slicedToArray(_meaningDescAndId$spl, 2),\n        meaningAndDesc = _meaningDescAndId$spl2[0],\n        customId = _meaningDescAndId$spl2[1];\n\n    var _meaningAndDesc$split = meaningAndDesc.split(MEANING_SEPARATOR, 2),\n        _meaningAndDesc$split2 = _slicedToArray(_meaningAndDesc$split, 2),\n        meaning = _meaningAndDesc$split2[0],\n        description = _meaningAndDesc$split2[1];\n\n    if (description === undefined) {\n      description = meaning;\n      meaning = undefined;\n    }\n\n    if (description === '') {\n      description = undefined;\n    }\n\n    return {\n      text: messageString,\n      meaning: meaning,\n      description: description,\n      customId: customId,\n      legacyIds: legacyIds\n    };\n  }\n}\n/**\n * Parse the given message part (`cooked` + `raw`) to extract any placeholder metadata from the\n * text.\n *\n * If the message part has a metadata block this function will extract the `placeholderName` and\n * `associatedMessageId` (if provided) from the block.\n *\n * These metadata properties are serialized in the string delimited by `@@`.\n *\n * For example:\n *\n * ```ts\n * `:placeholder-name@@associated-id:`\n * ```\n *\n * @param cooked The cooked version of the message part to parse.\n * @param raw The raw version of the message part to parse.\n * @returns A object containing the metadata (`placeholderName` and `associatedMessageId`) of the\n *     preceding placeholder, along with the static text that follows.\n */\n\n\nfunction parsePlaceholder(cooked, raw) {\n  var _splitBlock2 = splitBlock(cooked, raw),\n      messagePart = _splitBlock2.text,\n      block = _splitBlock2.block;\n\n  if (block === undefined) {\n    return {\n      messagePart: messagePart\n    };\n  } else {\n    var _block$split3 = block.split(ID_SEPARATOR),\n        _block$split4 = _slicedToArray(_block$split3, 2),\n        placeholderName = _block$split4[0],\n        associatedMessageId = _block$split4[1];\n\n    return {\n      messagePart: messagePart,\n      placeholderName: placeholderName,\n      associatedMessageId: associatedMessageId\n    };\n  }\n}\n/**\n * Split a message part (`cooked` + `raw`) into an optional delimited \"block\" off the front and the\n * rest of the text of the message part.\n *\n * Blocks appear at the start of message parts. They are delimited by a colon `:` character at the\n * start and end of the block.\n *\n * If the block is in the first message part then it will be metadata about the whole message:\n * meaning, description, id.  Otherwise it will be metadata about the immediately preceding\n * substitution: placeholder name.\n *\n * Since blocks are optional, it is possible that the content of a message block actually starts\n * with a block marker. In this case the marker must be escaped `\\:`.\n *\n * @param cooked The cooked version of the message part to parse.\n * @param raw The raw version of the message part to parse.\n * @returns An object containing the `text` of the message part and the text of the `block`, if it\n * exists.\n * @throws an error if the `block` is unterminated\n */\n\n\nfunction splitBlock(cooked, raw) {\n  if (raw.charAt(0) !== BLOCK_MARKER$1) {\n    return {\n      text: cooked\n    };\n  } else {\n    var endOfBlock = findEndOfBlock(cooked, raw);\n    return {\n      block: cooked.substring(1, endOfBlock),\n      text: cooked.substring(endOfBlock + 1)\n    };\n  }\n}\n\nfunction computePlaceholderName(index) {\n  return index === 1 ? 'PH' : \"PH_\".concat(index - 1);\n}\n/**\n * Find the end of a \"marked block\" indicated by the first non-escaped colon.\n *\n * @param cooked The cooked string (where escaped chars have been processed)\n * @param raw The raw string (where escape sequences are still in place)\n *\n * @returns the index of the end of block marker\n * @throws an error if the block is unterminated\n */\n\n\nfunction findEndOfBlock(cooked, raw) {\n  for (var cookedIndex = 1, rawIndex = 1; cookedIndex < cooked.length; cookedIndex++, rawIndex++) {\n    if (raw[rawIndex] === '\\\\') {\n      rawIndex++;\n    } else if (cooked[cookedIndex] === BLOCK_MARKER$1) {\n      return cookedIndex;\n    }\n  }\n\n  throw new Error(\"Unterminated $localize metadata block in \\\"\".concat(raw, \"\\\".\"));\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar MissingTranslationError = /*#__PURE__*/function (_Error) {\n  _inherits(MissingTranslationError, _Error);\n\n  var _super = _createSuper(MissingTranslationError);\n\n  function MissingTranslationError(parsedMessage) {\n    var _this;\n\n    _classCallCheck(this, MissingTranslationError);\n\n    _this = _super.call(this, \"No translation found for \".concat(describeMessage(parsedMessage), \".\"));\n    _this.parsedMessage = parsedMessage;\n    _this.type = 'MissingTranslationError';\n    return _this;\n  }\n\n  return _createClass(MissingTranslationError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nfunction isMissingTranslationError(e) {\n  return e.type === 'MissingTranslationError';\n}\n/**\n * Translate the text of the `$localize` tagged-string (i.e. `messageParts` and\n * `substitutions`) using the given `translations`.\n *\n * The tagged-string is parsed to extract its `messageId` which is used to find an appropriate\n * `ParsedTranslation`. If this doesn't match and there are legacy ids then try matching a\n * translation using those.\n *\n * If one is found then it is used to translate the message into a new set of `messageParts` and\n * `substitutions`.\n * The translation may reorder (or remove) substitutions as appropriate.\n *\n * If there is no translation with a matching message id then an error is thrown.\n * If a translation contains a placeholder that is not found in the message being translated then an\n * error is thrown.\n */\n\n\nfunction translate$1(translations, messageParts, substitutions) {\n  var message = parseMessage(messageParts, substitutions); // Look up the translation using the messageId, and then the legacyId if available.\n\n  var translation = translations[message.id]; // If the messageId did not match a translation, try matching the legacy ids instead\n\n  if (message.legacyIds !== undefined) {\n    for (var i = 0; i < message.legacyIds.length && translation === undefined; i++) {\n      translation = translations[message.legacyIds[i]];\n    }\n  }\n\n  if (translation === undefined) {\n    throw new MissingTranslationError(message);\n  }\n\n  return [translation.messageParts, translation.placeholderNames.map(function (placeholder) {\n    if (message.substitutions.hasOwnProperty(placeholder)) {\n      return message.substitutions[placeholder];\n    } else {\n      throw new Error(\"There is a placeholder name mismatch with the translation provided for the message \".concat(describeMessage(message), \".\\n\") + \"The translation contains a placeholder with name \".concat(placeholder, \", which does not exist in the message.\"));\n    }\n  })];\n}\n/**\n * Parse the `messageParts` and `placeholderNames` out of a target `message`.\n *\n * Used by `loadTranslations()` to convert target message strings into a structure that is more\n * appropriate for doing translation.\n *\n * @param message the message to be parsed.\n */\n\n\nfunction parseTranslation(messageString) {\n  var parts = messageString.split(/{\\$([^}]*)}/);\n  var messageParts = [parts[0]];\n  var placeholderNames = [];\n\n  for (var i = 1; i < parts.length - 1; i += 2) {\n    placeholderNames.push(parts[i]);\n    messageParts.push(\"\".concat(parts[i + 1]));\n  }\n\n  var rawMessageParts = messageParts.map(function (part) {\n    return part.charAt(0) === BLOCK_MARKER$1 ? '\\\\' + part : part;\n  });\n  return {\n    text: messageString,\n    messageParts: makeTemplateObject(messageParts, rawMessageParts),\n    placeholderNames: placeholderNames\n  };\n}\n/**\n * Create a `ParsedTranslation` from a set of `messageParts` and `placeholderNames`.\n *\n * @param messageParts The message parts to appear in the ParsedTranslation.\n * @param placeholderNames The names of the placeholders to intersperse between the `messageParts`.\n */\n\n\nfunction makeParsedTranslation(messageParts) {\n  var placeholderNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var messageString = messageParts[0];\n\n  for (var i = 0; i < placeholderNames.length; i++) {\n    messageString += \"{$\".concat(placeholderNames[i], \"}\").concat(messageParts[i + 1]);\n  }\n\n  return {\n    text: messageString,\n    messageParts: makeTemplateObject(messageParts, messageParts),\n    placeholderNames: placeholderNames\n  };\n}\n/**\n * Create the specialized array that is passed to tagged-string tag functions.\n *\n * @param cooked The message parts with their escape codes processed.\n * @param raw The message parts with their escaped codes as-is.\n */\n\n\nfunction makeTemplateObject(cooked, raw) {\n  Object.defineProperty(cooked, 'raw', {\n    value: raw\n  });\n  return cooked;\n}\n\nfunction describeMessage(message) {\n  var meaningString = message.meaning && \" - \\\"\".concat(message.meaning, \"\\\"\");\n  var legacy = message.legacyIds && message.legacyIds.length > 0 ? \" [\".concat(message.legacyIds.map(function (l) {\n    return \"\\\"\".concat(l, \"\\\"\");\n  }).join(', '), \"]\") : '';\n  return \"\\\"\".concat(message.id, \"\\\"\").concat(legacy, \" (\\\"\").concat(message.text, \"\\\"\").concat(meaningString, \")\");\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Load translations for use by `$localize`, if doing runtime translation.\n *\n * If the `$localize` tagged strings are not going to be replaced at compiled time, it is possible\n * to load a set of translations that will be applied to the `$localize` tagged strings at runtime,\n * in the browser.\n *\n * Loading a new translation will overwrite a previous translation if it has the same `MessageId`.\n *\n * Note that `$localize` messages are only processed once, when the tagged string is first\n * encountered, and does not provide dynamic language changing without refreshing the browser.\n * Loading new translations later in the application life-cycle will not change the translated text\n * of messages that have already been translated.\n *\n * The message IDs and translations are in the same format as that rendered to \"simple JSON\"\n * translation files when extracting messages. In particular, placeholders in messages are rendered\n * using the `{$PLACEHOLDER_NAME}` syntax. For example the message from the following template:\n *\n * ```html\n * <div i18n>pre<span>inner-pre<b>bold</b>inner-post</span>post</div>\n * ```\n *\n * would have the following form in the `translations` map:\n *\n * ```ts\n * {\n *   \"2932901491976224757\":\n *      \"pre{$START_TAG_SPAN}inner-pre{$START_BOLD_TEXT}bold{$CLOSE_BOLD_TEXT}inner-post{$CLOSE_TAG_SPAN}post\"\n * }\n * ```\n *\n * @param translations A map from message ID to translated message.\n *\n * These messages are processed and added to a lookup based on their `MessageId`.\n *\n * @see `clearTranslations()` for removing translations loaded using this function.\n * @see `$localize` for tagging messages as needing to be translated.\n * @publicApi\n */\n\n\nfunction loadTranslations(translations) {\n  // Ensure the translate function exists\n  if (!$localize.translate) {\n    $localize.translate = translate;\n  }\n\n  if (!$localize.TRANSLATIONS) {\n    $localize.TRANSLATIONS = {};\n  }\n\n  Object.keys(translations).forEach(function (key) {\n    $localize.TRANSLATIONS[key] = parseTranslation(translations[key]);\n  });\n}\n/**\n * Remove all translations for `$localize`, if doing runtime translation.\n *\n * All translations that had been loading into memory using `loadTranslations()` will be removed.\n *\n * @see `loadTranslations()` for loading translations at runtime.\n * @see `$localize` for tagging messages as needing to be translated.\n *\n * @publicApi\n */\n\n\nfunction clearTranslations() {\n  $localize.translate = undefined;\n  $localize.TRANSLATIONS = {};\n}\n/**\n * Translate the text of the given message, using the loaded translations.\n *\n * This function may reorder (or remove) substitutions as indicated in the matching translation.\n */\n\n\nfunction translate(messageParts, substitutions) {\n  try {\n    return translate$1($localize.TRANSLATIONS, messageParts, substitutions);\n  } catch (e) {\n    console.warn(e.message);\n    return [messageParts, substitutions];\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Always use __globalThis if available, which is the spec-defined global variable across all\n// environments, then fallback to __global first, because in Node tests both __global and\n// __window may be defined and _global should be __global in that case. Note: Typeof/Instanceof\n// checks are considered side-effects in Terser. We explicitly mark this as side-effect free:\n// https://github.com/terser/terser/issues/250.\n\n\nvar _global = /* @__PURE__ */function () {\n  return typeof globalThis !== 'undefined' && globalThis || typeof global !== 'undefined' && global || typeof window !== 'undefined' && window || typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && self;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Tag a template literal string for localization.\n *\n * For example:\n *\n * ```ts\n * $localize `some string to localize`\n * ```\n *\n * **Providing meaning, description and id**\n *\n * You can optionally specify one or more of `meaning`, `description` and `id` for a localized\n * string by pre-pending it with a colon delimited block of the form:\n *\n * ```ts\n * $localize`:meaning|description@@id:source message text`;\n *\n * $localize`:meaning|:source message text`;\n * $localize`:description:source message text`;\n * $localize`:@@id:source message text`;\n * ```\n *\n * This format is the same as that used for `i18n` markers in Angular templates. See the\n * [Angular i18n guide](guide/i18n-common-prepare#mark-text-in-component-template).\n *\n * **Naming placeholders**\n *\n * If the template literal string contains expressions, then the expressions will be automatically\n * associated with placeholder names for you.\n *\n * For example:\n *\n * ```ts\n * $localize `Hi ${name}! There are ${items.length} items.`;\n * ```\n *\n * will generate a message-source of `Hi {$PH}! There are {$PH_1} items`.\n *\n * The recommended practice is to name the placeholder associated with each expression though.\n *\n * Do this by providing the placeholder name wrapped in `:` characters directly after the\n * expression. These placeholder names are stripped out of the rendered localized string.\n *\n * For example, to name the `items.length` expression placeholder `itemCount` you write:\n *\n * ```ts\n * $localize `There are ${items.length}:itemCount: items`;\n * ```\n *\n * **Escaping colon markers**\n *\n * If you need to use a `:` character directly at the start of a tagged string that has no\n * metadata block, or directly after a substitution expression that has no name you must escape\n * the `:` by preceding it with a backslash:\n *\n * For example:\n *\n * ```ts\n * // message has a metadata block so no need to escape colon\n * $localize `:some description::this message starts with a colon (:)`;\n * // no metadata block so the colon must be escaped\n * $localize `\\:this message starts with a colon (:)`;\n * ```\n *\n * ```ts\n * // named substitution so no need to escape colon\n * $localize `${label}:label:: ${}`\n * // anonymous substitution so colon must be escaped\n * $localize `${label}\\: ${}`\n * ```\n *\n * **Processing localized strings:**\n *\n * There are three scenarios:\n *\n * * **compile-time inlining**: the `$localize` tag is transformed at compile time by a\n * transpiler, removing the tag and replacing the template literal string with a translated\n * literal string from a collection of translations provided to the transpilation tool.\n *\n * * **run-time evaluation**: the `$localize` tag is a run-time function that replaces and\n * reorders the parts (static strings and expressions) of the template literal string with strings\n * from a collection of translations loaded at run-time.\n *\n * * **pass-through evaluation**: the `$localize` tag is a run-time function that simply evaluates\n * the original template literal string without applying any translations to the parts. This\n * version is used during development or where there is no need to translate the localized\n * template literals.\n *\n * @param messageParts a collection of the static parts of the template string.\n * @param expressions a collection of the values of each placeholder in the template string.\n * @returns the translated string, with the `messageParts` and `expressions` interleaved together.\n *\n * @globalApi\n * @publicApi\n */\n\n\nvar $localize$1 = function $localize$1(messageParts) {\n  for (var _len = arguments.length, expressions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    expressions[_key - 1] = arguments[_key];\n  }\n\n  if ($localize$1.translate) {\n    // Don't use array expansion here to avoid the compiler adding `__read()` helper unnecessarily.\n    var translation = $localize$1.translate(messageParts, expressions);\n    messageParts = translation[0];\n    expressions = translation[1];\n  }\n\n  var message = stripBlock(messageParts[0], messageParts.raw[0]);\n\n  for (var i = 1; i < messageParts.length; i++) {\n    message += expressions[i - 1] + stripBlock(messageParts[i], messageParts.raw[i]);\n  }\n\n  return message;\n};\n\nvar BLOCK_MARKER = ':';\n/**\n * Strip a delimited \"block\" from the start of the `messagePart`, if it is found.\n *\n * If a marker character (:) actually appears in the content at the start of a tagged string or\n * after a substitution expression, where a block has not been provided the character must be\n * escaped with a backslash, `\\:`. This function checks for this by looking at the `raw`\n * messagePart, which should still contain the backslash.\n *\n * @param messagePart The cooked message part to process.\n * @param rawMessagePart The raw message part to check.\n * @returns the message part with the placeholder name stripped, if found.\n * @throws an error if the block is unterminated\n */\n\nfunction stripBlock(messagePart, rawMessagePart) {\n  return rawMessagePart.charAt(0) === BLOCK_MARKER ? messagePart.substring(findEndOfBlock(messagePart, rawMessagePart) + 1) : messagePart;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nexport { clearTranslations, loadTranslations, $localize$1 as ɵ$localize, MissingTranslationError as ɵMissingTranslationError, _global as ɵ_global, findEndOfBlock as ɵfindEndOfBlock, isMissingTranslationError as ɵisMissingTranslationError, makeParsedTranslation as ɵmakeParsedTranslation, makeTemplateObject as ɵmakeTemplateObject, parseMessage as ɵparseMessage, parseMetadata as ɵparseMetadata, parseTranslation as ɵparseTranslation, splitBlock as ɵsplitBlock, translate$1 as ɵtranslate }; //# sourceMappingURL=localize.mjs.map","map":null,"metadata":{},"sourceType":"module"}